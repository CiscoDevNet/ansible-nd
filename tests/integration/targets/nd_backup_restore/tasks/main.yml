# Test code for the ND modules
# Copyright: (c) 2023, Shreyas Srish (@shrsr) <ssrish@cisco.com>
# Copyright: (c) 2025, Sabari Jaganathan (@sajagana) <sajagana@cisco.com>

# GNU General Public License v3.0+ (see LICENSE or https://www.gnu.org/licenses/gpl-3.0.txt)
- name: Set vars
  ansible.builtin.set_fact:
    nd_info: &nd_info
      output_level: '{{ mso_output_level | default("debug") }}'
      timeout: 90 # Increased to 90 to extend the task timeout, as backup restore tasks commonly require 10-15 minutes or more.

# QUERY VERSION
- name: Query ND version
  cisco.nd.nd_version:
    state: query
  register: version

- name: Create a directory if it does not exist
  ansible.builtin.file:
    path: "{{ role_path }}/backups"
    state: directory
    mode: 0775

- name: Execute tasks only for ND version >= 3.2.1
  when: version.current.platformVersion is version('3.2.1', '>=')
  block:
    # CLEAN TEST ENVIRONMENT
    - name: Query all routes
      cisco.nd.nd_rest:
        method: get
        path: /api/config/class/routes/
      register: setup_query_all_routes

    - name: Delete all Data Routes
      cisco.nd.nd_rest:
        method: delete
        ignore_previous_state: true
        path: "/api/config/routes/{{ item.destination }}"
      loop: "{{ setup_query_all_routes.current | list }}"

    - name: Query all backups
      cisco.nd.nd_backup:
        output_level: debug
        state: query
      register: setup_query_all_backups

    - name: Delete all backups
      cisco.nd.nd_backup:
        output_level: debug
        name: "{{ item.name }}"
        state: absent
      loop: "{{ setup_query_all_backups.current | list }}"
      delay: 5

    # Local backup restore test
    - name: Add Data Route before ND local backup
      cisco.nd.nd_rest:
        path: /api/config/routes/
        method: post
        content:
          target: Data
          destination: 12.23.45.68/32

    - name: Create ND local backup
      cisco.nd.nd_backup:
        output_level: debug
        name: localbackup
        encryption_key: testtest1
        state: backup

    - name: Query ND local backup status
      cisco.nd.nd_backup:
        <<: *nd_info
        name: localbackup
        state: query
      register: query_local_backup_status
      until:
        - query_local_backup_status.current is defined
        - query_local_backup_status.current != {}
        - query_local_backup_status.current.status == "success"
      retries: 80
      delay: 20

    - name: Delete Data Route after ND local backup
      cisco.nd.nd_rest:
        ignore_previous_state: true
        method: delete
        output_level: debug
        path: /api/config/routes/12.23.45.68%2f32

    - name: Restore ND local backup from the ND backup list (check_mode)
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: localbackup
        encryption_key: testtest1
        state: restore
      check_mode: true
      register: cm_restore_local_backup

    - name: Restore ND local backup from the ND backup list
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        output_level: debug
        name: localbackup
        encryption_key: testtest1
        state: restore
      register: restore_local_backup

    - name: Query ND local backup restore status
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: query
      register: query_local_backup_restore_status
      until:
        - query_local_backup_restore_status.current is defined
        - query_local_backup_restore_status.current != {}
        - query_local_backup_restore_status.current.state == "complete"
      retries: 200
      delay: 20

    - name: Query Data Route after ND local backup restore
      cisco.nd.nd_rest:
        method: get
        path: /api/config/class/routes/
      register: query_all_routes

    - name: Assertion check for ND local backup restore
      ansible.builtin.assert:
        that:
          - cm_restore_local_backup is changed
          - cm_restore_local_backup.current.filePath is none
          - cm_restore_local_backup.current.name == "localbackup"
          - cm_restore_local_backup.current.ignorePersistentIPs == false
          - cm_restore_local_backup.current.type == "config-only"
          - restore_local_backup is changed
          - restore_local_backup.current != {}
          - restore_local_backup.current.state == "processing"
          - restore_local_backup.current.operation == "restore"
          - restore_local_backup.current.restoreConfig.path == "localbackup.tar.gz"
          - restore_local_backup.current.restoreConfig.source == ""
          - restore_local_backup.current.restoreConfig.type == "config-only"
          - query_all_routes is not changed
          - query_all_routes.current | length == 1
          - query_all_routes.current.0.target == "Data"
          - query_all_routes.current.0.destination == "12.23.45.68/32"

    - name: Delete all Data Routes
      cisco.nd.nd_rest:
        method: delete
        ignore_previous_state: true
        path: "/api/config/routes/{{ item.destination }}"
      loop: "{{ query_all_routes.current | list }}"

    - name: Query all backups
      cisco.nd.nd_backup:
        output_level: debug
        state: query
      register: query_all_backups

    - name: Delete all backups
      cisco.nd.nd_backup:
        output_level: debug
        name: "{{ item.name }}"
        state: absent
      loop: "{{ query_all_backups.current | list }}"
      delay: 5

    # Remote backup restore test
    - name: Add Data Route before ND remote backup
      cisco.nd.nd_rest:
        output_level: debug
        path: /api/config/routes/
        method: post
        content: "{{ item }}"
      loop:
        - target: Data
          destination: 12.23.45.68/32
        - target: Data
          destination: 12.23.45.69/32

    - name: Create ND remote backup
      cisco.nd.nd_backup:
        output_level: debug
        name: remotebackup
        encryption_key: testtest1
        remote_location: test
        state: backup

    - name: Query ND remote backup status
      cisco.nd.nd_backup:
        <<: *nd_info
        name: remotebackup
        state: query
      register: query_remote_backup_status
      until:
        - query_remote_backup_status.current is defined
        - query_remote_backup_status.current != {}
        - query_remote_backup_status.current.status == "success"
      retries: 80
      delay: 20

    - name: Delete Data Route after ND remote backup
      cisco.nd.nd_rest:
        output_level: debug
        ignore_previous_state: true
        method: delete
        path: "{{ item }}"
      loop:
        - /api/config/routes/12.23.45.68%2f32
        - /api/config/routes/12.23.45.69%2f32

    - name: Restore ND remote backup from the remote storage location (check_mode)
      cisco.nd.nd_backup_restore:
        output_level: debug
        remote_location: test # Remote storage location name
        encryption_key: testtest1
        file_location: "/home/backup/{{ansible_host | replace('.', '_')}}/remotebackup.tar.gz"
        state: restore
      check_mode: true
      register: cm_restore_remote_backup

    - name: Restore ND remote backup from the remote storage location
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        output_level: debug
        remote_location: test # Remote storage location name
        encryption_key: testtest1
        file_location: "/home/backup/{{ansible_host | replace('.', '_')}}/remotebackup.tar.gz"
        state: restore
      register: restore_remote_backup

    - name: Query ND remote backup restore status
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: query
      register: query_remote_backup_restore_status
      until:
        - query_remote_backup_restore_status.current is defined
        - query_remote_backup_restore_status.current != {}
        - query_remote_backup_restore_status.current.state == "complete"
      retries: 200
      delay: 20

    - name: Query Data Route after ND remote backup restore
      cisco.nd.nd_rest:
        output_level: debug
        method: get
        path: /api/config/class/routes/
      register: query_all_routes

    - name: Assertion check for ND remote backup restore
      ansible.builtin.assert:
        that:
          - cm_restore_remote_backup is changed
          - cm_restore_remote_backup.current.filePath == "/home/backup/{{ansible_host | replace('.', '_')}}/remotebackup.tar.gz"
          - cm_restore_remote_backup.current.path == "/home/backup/{{ansible_host | replace('.', '_')}}/remotebackup.tar.gz"
          - cm_restore_remote_backup.current.source == "test"
          - cm_restore_remote_backup.current.ignorePersistentIPs == false
          - cm_restore_remote_backup.current.type == "config-only"
          - restore_remote_backup is changed
          - restore_remote_backup.current != {}
          - restore_remote_backup.current.state == "processing"
          - restore_remote_backup.current.operation == "restore"
          - restore_remote_backup.current.restoreConfig.path == "/home/backup/{{ansible_host | replace('.', '_')}}/remotebackup.tar.gz"
          - restore_remote_backup.current.restoreConfig.source == "test" # Remote storage location name
          - restore_remote_backup.current.restoreConfig.type == "config-only"
          - query_all_routes is not changed
          - query_all_routes.current | length == 2
          - query_all_routes.current.0.target == "Data"
          - query_all_routes.current.0.destination == "12.23.45.68/32"
          - query_all_routes.current.1.target == "Data"
          - query_all_routes.current.1.destination == "12.23.45.69/32"

    - name: Delete all Data Routes
      cisco.nd.nd_rest:
        output_level: debug
        method: delete
        ignore_previous_state: true
        path: "/api/config/routes/{{ item.destination }}"
      loop: "{{ query_all_routes.current | list }}"

    - name: Query all backups
      cisco.nd.nd_backup:
        output_level: debug
        state: query
      register: query_all_backups

    - name: Delete all backups
      cisco.nd.nd_backup:
        output_level: debug
        name: "{{ item.name }}"
        state: absent
      loop: "{{ query_all_backups.current | list }}"
      delay: 5

    # Local backup and download restore test
    - name: Add Data Route before ND local backup download
      cisco.nd.nd_rest:
        output_level: debug
        path: /api/config/routes/
        method: post
        content: "{{ item }}"
      loop:
        - target: Data
          destination: 12.23.45.68/32
        - target: Data
          destination: 12.23.45.69/32
        - target: Data
          destination: 12.23.45.70/32

    - name: Create ND local backup
      cisco.nd.nd_backup:
        output_level: debug
        name: localbackupbownload
        encryption_key: testtest1
        state: backup

    - name: Query ND local backup status
      cisco.nd.nd_backup:
        <<: *nd_info
        name: localbackupbownload
        state: query
      register: query_local_backup_status
      until:
        - query_local_backup_status.current is defined
        - query_local_backup_status.current != {}
        - query_local_backup_status.current.status == "success"
      retries: 80
      delay: 20

    - name: Download ND local backup file
      cisco.nd.nd_backup:
        name: localbackupbownload
        file_location: "{{ role_path }}/backups/localbackupbownload.tar.gz"
        state: download

    - name: Delete Data Route after ND local and download
      cisco.nd.nd_rest:
        output_level: debug
        method: delete
        ignore_previous_state: true
        path: "{{ item }}"
      loop:
        - /api/config/routes/12.23.45.68%2f32
        - /api/config/routes/12.23.45.69%2f32
        - /api/config/routes/12.23.45.70%2f32

    - name: Restore ND local downloaded backup from the local machine (check_mode)
      cisco.nd.nd_backup_restore:
        output_level: debug
        encryption_key: testtest1
        file_location: "{{ role_path }}/backups/localbackupbownload.tar.gz"
        state: restore
      check_mode: true
      register: cm_restore_downloaded_local_backup

    - name: Restore ND local downloaded backup from the local machine
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        output_level: debug
        encryption_key: testtest1
        file_location: "{{ role_path }}/backups/localbackupbownload.tar.gz"
        state: restore
      register: restore_downloaded_local_backup

    - name: Query ND downloaded local backup restore status
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: query
      register: query_downloaded_backup_restore_status
      until:
        - query_downloaded_backup_restore_status.current is defined
        - query_downloaded_backup_restore_status.current != {}
        - query_downloaded_backup_restore_status.current.state == "complete"
      retries: 200
      delay: 20

    - name: Query Data Route after ND downloaded local backup file restore
      cisco.nd.nd_rest:
        output_level: debug
        method: get
        path: /api/config/class/routes/
      register: query_all_routes

    - name: Assertion check for ND downloaded local backup restore
      ansible.builtin.assert:
        that:
          - cm_restore_downloaded_local_backup is changed
          - cm_restore_downloaded_local_backup.current.filePath is match (".+/localbackupbownload.tar.gz")
          - cm_restore_downloaded_local_backup.current.ignorePersistentIPs == false
          - cm_restore_downloaded_local_backup.current.encryptionKey == "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
          - cm_restore_downloaded_local_backup.current.type == "config-only"
          - cm_restore_downloaded_local_backup.previous == {}
          - cm_restore_downloaded_local_backup.proposed.filePath is match (".+/localbackupbownload.tar.gz")
          - cm_restore_downloaded_local_backup.proposed.ignorePersistentIPs == false
          - cm_restore_downloaded_local_backup.proposed.encryptionKey == "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER"
          - cm_restore_downloaded_local_backup.proposed.type == "config-only"
          - restore_downloaded_local_backup is changed
          - restore_downloaded_local_backup.current != {}
          - restore_downloaded_local_backup.current.state == "processing"
          - restore_downloaded_local_backup.current.operation == "restore"
          - restore_downloaded_local_backup.current.restoreConfig.path is defined
          - restore_downloaded_local_backup.current.restoreConfig.source == ""
          - restore_downloaded_local_backup.current.restoreConfig.type == "config-only"
          - query_all_routes is not changed
          - query_all_routes.current | length == 3
          - query_all_routes.current.0.target == "Data"
          - query_all_routes.current.0.destination == "12.23.45.68/32"
          - query_all_routes.current.1.target == "Data"
          - query_all_routes.current.1.destination == "12.23.45.69/32"
          - query_all_routes.current.2.target == "Data"
          - query_all_routes.current.2.destination == "12.23.45.70/32"

    - name: Delete all Data Routes
      cisco.nd.nd_rest:
        output_level: debug
        method: delete
        ignore_previous_state: true
        path: "/api/config/routes/{{ item.destination }}"
      loop: "{{ query_all_routes.current | list }}"

    - name: Delete imported backup file (check_mode)
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: absent
      check_mode: true
      register: cm_rm_imported_backup

    - name: Delete imported backup file
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: absent
      register: rm_imported_backup

    - name: Delete imported backup file again
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        state: absent
      register: rm_imported_backup_again

    - name: Assertion check for delete imported backup file
      ansible.builtin.assert:
        that:
          - cm_rm_imported_backup is changed
          - cm_rm_imported_backup.current == {}
          - cm_rm_imported_backup.previous.error == ""
          - cm_rm_imported_backup.previous.operation == "restore"
          - cm_rm_imported_backup.previous.restoreConfig.type == "config-only"
          - cm_rm_imported_backup.previous.state == "complete"
          - cm_rm_imported_backup.proposed == {}
          - rm_imported_backup is changed
          - rm_imported_backup.current == {}
          - rm_imported_backup.previous.error == ""
          - rm_imported_backup.previous.operation == "restore"
          - rm_imported_backup.previous.restoreConfig.type == "config-only"
          - rm_imported_backup.previous.state == "complete"
          - rm_imported_backup_again is not changed
          - rm_imported_backup_again.current == {}
          - rm_imported_backup_again.previous == {}
          - rm_imported_backup_again.proposed == {}

    # ERROR
    - name: Negative test restore ND local downloaded backup from the local machine with wrong encryption_key
      cisco.nd.nd_backup_restore:
        <<: *nd_info
        output_level: debug
        encryption_key: testtest12
        file_location: "{{ role_path }}/backups/localbackupbownload.tar.gz"
        state: restore
      register: nt_restore_downloaded_local_backup
      ignore_errors: true

    - name: Assertion check for negative test restore ND local downloaded backup from the local machine with wrong encryption_key
      ansible.builtin.assert:
        that:
          - nt_restore_downloaded_local_backup is failed
          - 'nt_restore_downloaded_local_backup.msg == "Backup file restore validation failed: error while reading header: Unable to read header (wrong encryption key?)."'

    # CLEAN TEST ENVIRONMENT
    - name: Query all backups
      cisco.nd.nd_backup:
        output_level: debug
        state: query
      register: query_all_backups

    - name: Delete all backups
      cisco.nd.nd_backup:
        output_level: debug
        name: "{{ item.name }}"
        state: absent
      loop: "{{ query_all_backups.current | list }}"
      delay: 5

- name: Execute tasks only for ND version < 3.2.1
  when: version.current.platformVersion is version('3.2.1', '<')
  block:
    - name: Create a route to have some config in the route cluster configuration
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        destination_ip: 12.23.45.68/32
        target_network: data
        state: present

    - name: Create a backup nexus
      cisco.nd.nd_backup:
        output_level: debug
        name: nexus
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: backup

    - name: Query all routes
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        state: query
      register: query_all_routes

    - name: Delete all routes to change the route configuration
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        destination_ip: "{{ item }}"
        state: absent
      loop: "{{ query_all_routes.current | map(attribute='spec.destination') | list }}"

    - name: Import the backup file nexus with restore job's name called nexus in check mode
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: restore
      check_mode: true
      register: restore_nexus_cm

    - name: Import the backup file nexus with restore job's name called nexus
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: restore
      register: restore_nexus

    - name: Query all routes again
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        state: query
      register: query_all_routes_again

    - name: Delete all routes again to add another restore job
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        destination_ip: "{{ item }}"
        state: absent
      loop: "{{ query_all_routes.current | map(attribute='spec.destination') | list }}"

    - name: Import the backup file nexus again with a different restore name nexus2
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus2
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: restore
      register: restore_nexus2

    - name: Query all routes after second import
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        state: query
      register: query_all_routes_after_second_import

    - name: Delete all routes again to add a third restore job
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        destination_ip: "{{ item }}"
        state: absent
      loop: "{{ query_all_routes.current | map(attribute='spec.destination') | list }}"

    - name: Import the backup file with the name nexus to have multiple restore jobs with the same name
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: restore
      register: restore_nexus_again

    - name: Query all routes after third import
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        state: query
      register: query_all_routes_after_third_import

    - name: Query a restore job
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus2
        state: query
      register: query_nexus2

    - name: Query all restore jobs
      cisco.nd.nd_backup_restore:
        output_level: debug
        state: query
      register: query_all

    - name: Delete a restore job in check mode
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus2
        state: absent
      check_mode: true
      register: delete_nexus2_cm

    - name: Delete a restore job
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus2
        state: absent
      register: delete_nexus2

    - name: Delete a restore job again
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus2
        state: absent
      register: delete_nexus2_again

    # Failure Scenarios
    - name: Try querying restore nexus
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        state: query
      ignore_errors: true
      register: query_duplicate_nexus

    - name: Try deleting restore nexus
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        state: absent
      ignore_errors: true
      register: delete_duplicate_nexus

    - name: Delete restore with the wrong restore key
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        restore_key: 0
        state: absent
      ignore_errors: true
      register: delete_wrong_key_nexus

    - name: Import backup to ND which already has the routes configured
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        encryption_key: testtest
        file_location: "{{ role_path }}/backups/nexus_{{ ansible_host }}.tgz"
        state: restore
      ignore_errors: true
      register: import_nexus_existing

    - name: Gather and sort the list of specs
      ansible.builtin.set_fact:
        query_all_routes_original: "{{ query_all_routes.current | map(attribute='spec') | list | sort(attribute='destination') }}"
        query_all_routes_restored1: "{{ query_all_routes_again.current | map(attribute='spec') | list | sort(attribute='destination') }}"
        query_all_routes_restored2: "{{ query_all_routes_after_second_import.current | map(attribute='spec') | list | sort(attribute='destination') }}"
        query_all_routes_restored3: "{{ query_all_routes_after_third_import.current | map(attribute='spec') | list | sort(attribute='destination') }}"

    - name: Verify all assertions
      ansible.builtin.assert:
        that:
          - restore_nexus_cm.changed is true
          - restore_nexus.changed is true
          - restore_nexus2.changed is true
          - restore_nexus_again.changed is true
          - query_all_routes_original == query_all_routes_restored1 == query_all_routes_restored2 == query_all_routes_restored3
          - query_nexus2.changed is false
          - query_nexus2.current.description == "nexus2"
          - query_all.current | length >= 3
          - delete_nexus2.changed is true
          - delete_nexus2_cm.changed is true
          - delete_nexus2_again.changed is false
          - delete_nexus2.current == delete_nexus2_cm.current == delete_nexus2_again.current == {}
          - query_duplicate_nexus.msg == delete_duplicate_nexus.msg == "Multiple restore jobs with the name 'nexus' found. Please provide a restore key for the corresponding restored job."
          - delete_wrong_key_nexus.msg == "Provided key for the restore 'nexus' not found. Please provide a valid restore key by querying all the restored jobs and looking up the desired restore key."

    - name: Query all restored jobs for deleting them
      cisco.nd.nd_backup_restore:
        output_level: debug
        state: query
      register: restores

    - name: Delete the other restored jobs to clean up the environment
      cisco.nd.nd_backup_restore:
        output_level: debug
        name: nexus
        restore_key: "{{ item }}"
        state: absent
      loop: "{{ restores.current | map(attribute='key') | list }}"

    - name: Query all backups for deleting them
      cisco.nd.nd_backup:
        output_level: debug
        state: query
      register: backups

    - name: Delete all backup jobs to clean up environment
      cisco.nd.nd_backup:
        output_level: debug
        name: nexus
        backup_key: "{{ item }}"
        state: absent
      loop: "{{ backups.current | map(attribute='key') | list }}"

    - name: Delete the route created in the beginning of this test
      cisco.nd.nd_cluster_config_route:
        output_level: debug
        destination_ip: 12.23.45.68/32
        state: absent
