#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2023, Shreyas Srish (@shrsr) <ssrish@cisco.com>
# Copyright: (c) 2025, Sabari Jaganathan (@sajagana) <sajagana@cisco.com>
# GNU General Public License v3.0+ (see LICENSE or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function

__metaclass__ = type

ANSIBLE_METADATA = {"metadata_version": "1.1", "status": ["preview"], "supported_by": "community"}

DOCUMENTATION = r"""
---
module: nd_backup
version_added: "0.5.0"
short_description: Manages backup on Nexus Dashboard.
description:
- Manages backup of the cluster configuration.
author:
- Shreyas Srish (@shrsr)
- Sabari Jaganathan (@sajagana)
options:
  name:
    description:
    - The name of a backup.
    aliases: [ backup_name ]
    type: str
  encryption_key:
    description:
    - The encryption_key for a backup file.
    - A minimum of 8 alphanumeric characters is required.
    type: str
  file_location:
    description:
    - The download path and file name for a backup.
    - When O(file_location) is specified, the backup will be created and automatically downloaded to the local machine at the designated path.
    aliases: [ local_path, path ]
    type: str
  backup_key:
    description:
    - The key generated by ND during creation of a backup.
    - This key is required when querying or deleting a backup among multiple backups that have the same name.
    - This key can be obtained by querying the backup.
    - This parameter is not supported on ND v3.2.1 and later.
    type: str
  backup_type:
    description:
    - This parameter is only supported on ND v3.2.1 and later.
    - The O(backup_type=config_only) option creates a snapshot that specifically captures the configuration settings of the Nexus Dashboard.
    - The O(backup_type=full) option creates a complete snapshot of the entire Nexus Dashboard.
    - When unspecified, the parameter defaults to O(backup_type=config_only).
    type: str
    choices: [ config_only, full ]
    aliases: [ type ]
  remote_location:
    description:
    - This parameter is only supported on ND v3.2.1 and later.
    - The name of the remote storage location.
    - Use O(remote_location="") to create local backup.
    default: ""
    type: str
  state:
    description:
    - Use O(state=backup) for creating and downloading a backup of the cluster config for the ND versions < 3.2.1.
    - Use O(state=backup) to create a cluster configuration backup. Automatic download is not supported for the ND versions >= 3.2.1.
    - After creation, use O(state=download) to download the backup file.
    - Use O(state=download) downloading a backup to the local machine, the O(state=download) is only supported on ND v3.2.1 and later.
    - Use O(state=query) for listing all the backed up files.
    - Use O(state=absent) for deleting a backup job.
    type: str
    choices: [ backup, download, query, absent ]
    default: backup
extends_documentation_fragment:
- cisco.nd.modules
- cisco.nd.check_mode
"""

EXAMPLES = r"""
- name: Create a backup for ND versions < 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest
    file_location: ./nexus.tgz
    state: backup

- name: Create a remote backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest1
    remote_location: remote_machine
    state: backup

- name: Create a local backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest1
    state: backup

- name: Create a backup and download it to the local machine for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    file_location: ./nexus.tgz
    encryption_key: testtest1
    state: backup

- name: Download a local/remote backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    state: download
    file_location: ./nexus.tgz

- name: Query a Backup job
  cisco.nd.nd_backup:
    name: nexus
    state: query
  register: query_result

- name: Query all the backup jobs
  cisco.nd.nd_backup:
    state: query
  register: query_results

- name: Delete a Backup job
  cisco.nd.nd_backup:
    name: nexus
    state: absent
"""

RETURN = r"""
"""

from ansible.module_utils._text import to_bytes
from ansible.module_utils.basic import AnsibleModule
from ansible_collections.cisco.nd.plugins.module_utils.nd import NDModule, nd_argument_spec, write_file
from ansible_collections.cisco.nd.plugins.module_utils.constants import BACKUP_TYPE


def main():
    argument_spec = nd_argument_spec()
    argument_spec.update(
        name=dict(type="str", aliases=["backup_name"]),
        encryption_key=dict(type="str", no_log=True),
        file_location=dict(type="str", aliases=["local_path", "path"]),
        backup_key=dict(type="str", no_log=False),
        remote_location=dict(type="str", default=""),
        backup_type=dict(type="str", choices=["config_only", "full"], aliases=["type"]),
        state=dict(type="str", default="backup", choices=["backup", "download", "query", "absent"]),
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
        required_if=[
            ["state", "backup", ["name", "encryption_key"]],
            ["state", "absent", ["name"]],
            ["state", "download", ["name", "file_location"]],
        ],
    )

    nd = NDModule(module)

    name = nd.params.get("name")
    encryption_key = nd.params.get("encryption_key")
    backup_key = nd.params.get("backup_key")
    file_location = nd.params.get("file_location")
    remote_location = nd.params.get("remote_location")
    backup_type = BACKUP_TYPE.get(nd.params.get("backup_type"))
    state = nd.params.get("state")

    path = "/nexus/infra/api/platform/v1/exports" if nd.version < "3.2.1" else "/api/action/class/backuprestore/backup"
    backups = nd.query_obj("/api/config/class/exports") if nd.version < "3.2.1" else nd.query_obj(path)

    if nd.version < "3.2.1":
        if not file_location and state in ["backup", "download"]:
            nd.fail_json("Parameter 'file_location' is required when state is 'backup|download' for ND versions < 3.2.1.")

        if encryption_key is not None and len(encryption_key) < 8:
            nd.fail_json("Please provide a minimum of 8 characters for the encryption key.")

        if name:
            backups_info = [file_dict for file_dict in backups if file_dict.get("description") == name]
            if len(backups_info) > 1 and backup_key is None and encryption_key is None:
                nd.fail_json("Multiple backups with the name '{0}' found. Please provide a backup key for the corresponding backup.".format(name))
            elif len(backups_info) == 1:
                backup_key = backups_info[0].get("key")
            elif backup_key is not None and backup_key not in [file_dict.get("key") for file_dict in backups_info]:
                nd.fail_json(
                    "Provided key for the backup '{0}' not found."
                    " Please provide a valid backup key by querying all the backups and looking up the desired backup key.".format(name)
                )
            nd.existing = next((file_dict for file_dict in backups_info if file_dict.get("key") == backup_key), {})
        else:
            nd.existing = backups
        nd.previous = nd.existing
    else:
        if name and backups:
            for backup in backups:
                if backup.get("name") == name:
                    nd.existing = backup
                    break
            nd.previous = nd.existing
        elif backups:
            nd.previous = nd.existing = backups

    if state == "absent":
        if not module.check_mode:
            absent_path = "{0}/{1}".format(path, backup_key) if nd.version < "3.2.1" else "{0}/{1}".format(path, name)
            nd.request(absent_path, method="DELETE")
        nd.existing = {}

    elif state == "backup":
        # The imported backup must be cleared before creating a new backup
        if not module.check_mode:
            backup_status = nd.query_obj("/api/action/class/backuprestore/status")
            if backup_status.get("operation") != "backup":
                nd.request("/api/action/class/backuprestore/restore/file-import", method="DELETE")

        if not nd.existing:
            if nd.version < "3.2.1":
                payload = {
                    "spec": {
                        "description": name,
                        "password": encryption_key,
                    },
                }
            else:
                payload = {
                    "name": name,
                    "type": backup_type,
                    "destination": remote_location,
                    "encryptionKey": encryption_key,
                }

            nd.sanitize(payload, collate=True)

            if not module.check_mode:
                response = None
                if nd.version < "3.2.1":
                    response = nd.request(path, method="POST", data=payload, output_format="raw")
                else:
                    nd.request(path, method="POST", data=payload)
                    nd.existing = nd.request("{0}/{1}".format(path, name), method="GET")

                if file_location:
                    if not response and nd.version >= "3.2.1":
                        response = nd.request("{0}/{1}?action=download".format(path, name), method="GET", data=None, output_format="raw")
                    write_file(module, file_location, to_bytes(response))
            elif module.check_mode:
                nd.existing = nd.proposed

    elif state == "download" and file_location and nd.existing and nd.version >= "3.2.1":
        if not module.check_mode:
            response = nd.request("{0}/{1}?action=download".format(path, name), method="GET", data=None, output_format="raw")
            write_file(module, file_location, to_bytes(response))

    nd.exit_json()


if __name__ == "__main__":
    main()
