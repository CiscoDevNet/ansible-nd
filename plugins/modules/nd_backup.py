#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2023, Shreyas Srish (@shrsr) <ssrish@cisco.com>
# GNU General Public License v3.0+ (see LICENSE or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function

__metaclass__ = type

ANSIBLE_METADATA = {"metadata_version": "1.1", "status": ["preview"], "supported_by": "community"}

DOCUMENTATION = r"""
---
module: nd_backup
short_description: Manages backup on Nexus Dashboard.
description:
- Manages backup of the cluster configuration.
author:
- Shreyas Srish (@shrsr)
options:
  name:
    description:
    - The name of a backup.
    aliases: [ backup_name ]
    type: str
  encryption_key:
    description:
    - The encryption_key for a backup file.
    type: str
  file_location:
    description:
    - The download path and file name for a backup.
    type: str
  backup_key:
    description:
    - The key generated by ND during creation of a backup.
    - This key is required when querying or deleting a backup among multiple backups that have the same name.
    - This key can be obtained by querying the backup.
    type: str
  state:
    description:
    - Use C(backup) for creating a backup of the cluster config.
    - Use C(query) for listing all the backed up files.
    - Use C(absent) for deleting a backup job.
    type: str
    choices: [ backup, query, absent ]
    default: backup
extends_documentation_fragment: cisco.nd.modules
"""

EXAMPLES = r"""
- name: Create a Backup
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest
    file_location: ./nexus.tgz
    state: backup

- name: Query a Backup
  cisco.nd.nd_backup:
    name: nexus
    state: query
  register: query_result

- name: Query all the backups
  cisco.nd.nd_backup:
    state: query
  register: query_results

- name: Delete a Backup log
  cisco.nd.nd_backup:
    name: nexus
    state: absent
"""

RETURN = r"""
"""

from ansible.module_utils._text import to_bytes
from ansible.module_utils.basic import AnsibleModule
from ansible_collections.cisco.nd.plugins.module_utils.nd import NDModule, nd_argument_spec, write_file


def main():
    argument_spec = nd_argument_spec()
    argument_spec.update(
        name=dict(type="str", aliases=["backup_name"]),
        encryption_key=dict(type="str", no_log=False),
        file_location=dict(type="str"),
        backup_key=dict(type="str", no_log=False),
        state=dict(type="str", default="backup", choices=["backup", "query", "absent"]),
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
        required_if=[
            ["state", "backup", ["name", "encryption_key", "file_location"]],
            ["state", "absent", ["name"]],
        ],
    )

    nd = NDModule(module)

    name = nd.params.get("name")
    encryption_key = nd.params.get("encryption_key")
    backup_key = nd.params.get("backup_key")
    file_location = nd.params.get("file_location")
    state = nd.params.get("state")

    if encryption_key is not None and len(encryption_key) < 8:
        nd.fail_json("Please provide a minimum of 8 characters for the encryption key.")

    path = "/nexus/infra/api/platform/v1/exports"
    # The below path for GET operation is to be replaced by an official documented API endpoint once it becomes available.
    backup_objs = nd.query_obj("/api/config/class/exports")
    backups_info = []
    if name:
        backups_info = [file_dict for file_dict in backup_objs if file_dict.get("description") == name]
        if len(backups_info) > 1 and backup_key is None and encryption_key is None:
            nd.fail_json("Multiple backups with the name '{0}' found. Please provide a backup key for the corresponding backup.".format(name))
        else:
            backup_keys = [file_dict.get("key") for file_dict in backups_info]
            if len(backups_info) == 1:
                backup_key = backup_keys[0]
            elif backup_key is not None and backup_key not in backup_keys:
                nd.fail_json(
                    "Provided key for the backup '{0}' not found."
                    " Please provide a valid backup key by querying all the backups and looking up the desired backup key.".format(name)
                )
        nd.existing = next((file_dict for file_dict in backups_info if file_dict.get("key") == backup_key), {})
    else:
        nd.existing = backup_objs

    nd.previous = nd.existing

    if state == "absent":
        if nd.existing:
            if not module.check_mode:
                nd.request("{0}/{1}".format(path, backup_key), method="DELETE")
            nd.existing = {}
    elif state == "backup":
        nd.previous = nd.existing = {}

        payload = {
            "spec": {
                "description": name,
                "password": encryption_key,
            },
        }

        nd.sanitize(payload, collate=True)

        if not module.check_mode:
            nd.request(path, method="POST", data=payload)
            write_file(module, file_location, to_bytes(nd.raw_output))
        nd.existing = nd.proposed

    nd.exit_json()


if __name__ == "__main__":
    main()
