#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2023, Shreyas Srish (@shrsr) <ssrish@cisco.com>
# Copyright: (c) 2025, Sabari Jaganathan (@sajagana) <sajagana@cisco.com>
# GNU General Public License v3.0+ (see LICENSE or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function

__metaclass__ = type

ANSIBLE_METADATA = {"metadata_version": "1.1", "status": ["preview"], "supported_by": "community"}

DOCUMENTATION = r"""
---
module: nd_backup
version_added: "0.5.0"
short_description: Manages backup on Nexus Dashboard.
description:
- Manages backup of the cluster configuration.
author:
- Shreyas Srish (@shrsr)
- Sabari Jaganathan (@sajagana)
options:
  name:
    description:
    - The name of a backup.
    aliases: [ backup_name ]
    type: str
  encryption_key:
    description:
    - The encryption_key for a backup file.
    - A minimum of 8 alphanumeric characters is required.
    type: str
  file_location:
    description:
    - The download path and file name for a backup.
    - When O(file_location) is specified, the backup will be created and automatically downloaded to the local machine at the designated path.
    type: str
  backup_key:
    description:
    - The key generated by ND during creation of a backup.
    - This key is required when querying or deleting a backup among multiple backups that have the same name.
    - This key can be obtained by querying the backup.
    - This parameter is not supported on ND v3.2.1 and later.
    type: str
  remote_location:
    description:
    - The name of the remote storage location. This parameter is only supported on ND v3.2.1 and later.
    - If the O(remote_location) parameter is not specified or O(remote_location="") during backup creation, a local backup will be created.
    type: str
  backup_type:
    description:
    - This parameter is only supported on ND v3.2.1 and later.
    - The O(backup_type=config_only) option creates a snapshot that specifically captures the configuration settings of the Nexus Dashboard.
    - The O(backup_type=full) option creates a complete snapshot of the entire Nexus Dashboard.
    type: str
    choices: [ config_only, full ]
    default: config_only
    aliases: [ type ]
  state:
    description:
    - Use O(state=backup) for creating and downloading a backup of the cluster config for the ND versions < 3.2.1.
    - Use O(state=backup) to create a cluster configuration backup. Automatic download is not supported for the ND versions >= 3.2.1.
    - After creation, use O(state=download) to download the backup file.
    - Use O(state=download) downloading a backup to the local machine, the O(state=download) is only supported on ND v3.2.1 and later.
    - Use O(state=query) for listing all the backed up files.
    - Use O(state=absent) for deleting a backup job.
    type: str
    choices: [ backup, download, query, absent ]
    default: backup
extends_documentation_fragment:
- cisco.nd.modules
- cisco.nd.check_mode
"""

EXAMPLES = r"""
- name: Create a backup for ND versions < 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest
    file_location: ./nexus.tgz
    state: backup

- name: Create a remote backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest1
    remote_location: remote_machine
    state: backup

- name: Create a local backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    encryption_key: testtest1
    state: backup

- name: Create a backup and download it to the local machine for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    file_location: ./nexus.tgz
    encryption_key: testtest1
    state: backup

- name: Download a local/remote backup for ND versions >= 3.2.1
  cisco.nd.nd_backup:
    name: nexus
    state: download
    file_location: ./nexus.tgz

- name: Query a Backup job
  cisco.nd.nd_backup:
    name: nexus
    state: query
  register: query_result

- name: Query all the backup jobs
  cisco.nd.nd_backup:
    state: query
  register: query_results

- name: Delete a Backup job
  cisco.nd.nd_backup:
    name: nexus
    state: absent
"""

RETURN = r"""
"""

from ansible.module_utils._text import to_bytes
from ansible.module_utils.basic import AnsibleModule
from ansible_collections.cisco.nd.plugins.module_utils.nd import NDModule, nd_argument_spec, write_file
from ansible_collections.cisco.nd.plugins.module_utils.utils import snake_to_camel


def main():
    argument_spec = nd_argument_spec()
    argument_spec.update(
        name=dict(type="str", aliases=["backup_name"]),
        encryption_key=dict(type="str", no_log=False),
        file_location=dict(type="str"),
        backup_key=dict(type="str", no_log=False),
        remote_location=dict(type="str"),
        backup_type=dict(type="str", default="config_only", choices=["config_only", "full"], aliases=["type"]),
        state=dict(type="str", default="backup", choices=["backup", "download", "query", "absent"]),
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
        required_if=[
            ["state", "backup", ["name", "encryption_key"]],
            ["state", "absent", ["name"]],
            ["state", "download", ["name", "file_location"]],
        ],
    )

    nd = NDModule(module)

    name = nd.params.get("name")
    encryption_key = nd.params.get("encryption_key")
    backup_key = nd.params.get("backup_key")
    file_location = nd.params.get("file_location")
    remote_location = nd.params.get("remote_location")
    backup_type = nd.params.get("backup_type")
    state = nd.params.get("state")

    if nd.version < "3.2.1":
        if not file_location and state in ["backup", "download"]:
            nd.fail_json("Parameter 'file_location' is required when state is 'backup|download' for ND versions < 3.2.1.")
        nd_backup_before_3_2_1(module, nd, name, encryption_key, file_location, backup_key, state)
    elif nd.version >= "3.2.1":
        nd_backup_from_3_2_1(module, nd, name, encryption_key, file_location, remote_location, backup_type, state)

    nd.exit_json()


def nd_backup_from_3_2_1(module, nd, name, encryption_key, file_location, remote_location, backup_type, state):
    if encryption_key is not None:
        if len(encryption_key) < 8:
            nd.fail_json("Please provide a minimum of 8 alphanumeric characters for the encryption key.")
        elif not (any(char.isalpha() for char in encryption_key) and any(char.isdigit() for char in encryption_key) and encryption_key.isalnum()):
            nd.fail_json("The encryption_key must contain at least one letter and one number, and have a minimum length of 8 characters.")

    path = "/api/v1/infra/backups"
    backups = nd.query_obj(path)
    if name and backups:
        for backup in backups.get("backups", []):
            if backup.get("name") == name:
                nd.existing = backup
                break
    else:
        nd.existing = backups.get("backups", [])

    if state == "absent" and nd.existing:
        nd.previous = nd.existing
        if not module.check_mode:
            nd.request("{0}/{1}".format(path, name), method="DELETE")
        nd.existing = {}

    elif state == "backup":
        if not nd.existing:
            payload = {
                "name": name,
                "type": snake_to_camel(backup_type),
                "destination": remote_location if remote_location else "",
                "encryptionKey": encryption_key,
            }
            nd.sanitize(payload, collate=True)

            if not module.check_mode:
                # Creates backup file and returns None
                nd.request(path, method="POST", data=payload)

                # Fetching the backup object details to set module current value
                nd.existing = nd.request("{0}/{1}".format(path, name), method="GET")

                if file_location:
                    response = nd.request("{0}/{1}/actions/download".format(path, name), method="GET", data=None, output_format="raw")
                    write_file(module, file_location, to_bytes(response))
            elif module.check_mode:
                nd.existing = nd.proposed
        else:
            nd.previous = nd.existing

    elif state == "download" and file_location and nd.existing:
        if not module.check_mode:
            response = nd.request("{0}/{1}/actions/download".format(path, name), method="GET", data=None, output_format="raw")
            write_file(module, file_location, to_bytes(response))


def nd_backup_before_3_2_1(module, nd, name, encryption_key, file_location, backup_key, state):
    if encryption_key is not None and len(encryption_key) < 8:
        nd.fail_json("Please provide a minimum of 8 characters for the encryption key.")

    path = "/nexus/infra/api/platform/v1/exports"
    # The below path for GET operation is to be replaced by an official documented API endpoint once it becomes available.
    backup_objs = nd.query_obj("/api/config/class/exports")

    if name:
        backups_info = [file_dict for file_dict in backup_objs if file_dict.get("description") == name]
        if len(backups_info) > 1 and backup_key is None and encryption_key is None:
            nd.fail_json("Multiple backups with the name '{0}' found. Please provide a backup key for the corresponding backup.".format(name))
        elif len(backups_info) == 1:
            backup_key = backups_info[0].get("key")
        elif backup_key is not None and backup_key not in [file_dict.get("key") for file_dict in backups_info]:
            nd.fail_json(
                "Provided key for the backup '{0}' not found."
                " Please provide a valid backup key by querying all the backups and looking up the desired backup key.".format(name)
            )
        nd.existing = next((file_dict for file_dict in backups_info if file_dict.get("key") == backup_key), {})
    else:
        nd.existing = backup_objs

    nd.previous = nd.existing

    if state == "absent":
        if nd.existing:
            if not module.check_mode:
                nd.request("{0}/{1}".format(path, backup_key), method="DELETE")
            nd.existing = {}
    elif state == "backup":
        nd.previous = nd.existing = {}

        payload = {
            "spec": {
                "description": name,
                "password": encryption_key,
            },
        }

        nd.sanitize(payload, collate=True)

        if not module.check_mode:
            response = nd.request(path, method="POST", data=payload, output_format="raw")
            write_file(module, file_location, to_bytes(response))
        nd.existing = nd.proposed


if __name__ == "__main__":
    main()
